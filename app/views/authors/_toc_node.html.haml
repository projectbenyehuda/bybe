-# rubocop:disable Style/CaseLikeIf
- nodeclass = case when toc_node.is_a?(TocTree::ManifestationNode) then 'manifestation-node' when toc_node.is_a?(TocTree::PlaceholderNode) then 'ph-node' else '' end
%li{ class: nodeclass, style: toc_node.is_a?(TocTree::ManifestationNode) ? '' : 'margin-top: 12px; margin-bottom: 10px;' }
  - if toc_node.is_a?(TocTree::ManifestationNode)
    - m = toc_node.manifestation
    - e = m.expression
    - w = e.work
    - genre = w.genre
    %span.sorting-metadata{ 'data-impressions': m.impressions_count, 'data-title': m.sort_title, 'data-pubdate': e.normalized_pub_date.present? ? e.normalized_pub_date.to_date.jd : nil, 'data-creation-date': w.normalized_creation_date.present? ? w.normalized_creation_date.to_date.jd : nil, 'data-upload-date': m.publication_date.to_date.jd }
    %span.by-icon-v02{ title: textify_genre(genre) }>= glyph_for_genre(genre)
    &nbsp;&rlm;
    - if m.published?
      = link_to manifestation_label(m, role, authority_id), manifestation_path(m)
      %span.hidden.metadata-creation-date
        != "&nbsp;&nbsp;&nbsp;"
        - if w.date.present?
          = "(#{w.date})"
      %span.hidden.metadata-pubdate
        != "&nbsp;&nbsp;&nbsp;"
        - if e.date.present?
          = "(#{e.date})"
      %span.hidden.metadata-upload-date
        != "&nbsp;&nbsp;&nbsp;"
        = "(#{m.publication_date})"
      - if uncollected
        %span.metadata-source-edition
          %br
          - edition = e.source_edition || ''
          - edition.strip!
          - if e.date.present?
            - edition += ', '+e.date
          = edition
    - else
      = manifestation_label(m, role, authority_id)
    %span.mtitle{ style: 'display:none' }= m.title
  - elsif toc_node.is_a?(TocTree::CollectionNode)
    -# Collection node
    - collection = toc_node.collection
    - type_prefix = collection.collection_type == 'uncollected' ? '' : textify_collection_type(collection.collection_type)
    - uncollected = collection.collection_type == 'uncollected'
    - children = toc_node.children_by_role(role, authority_id, involved_on_collection_level)
    - children.reject!{ |child| child.is_a?(TocTree::ManifestationNode) && child.manifestation.status != 'published' } # don't show deleted or unpublished manifestations in the TOC
    - if !uncollected || children.present?
      %li.by-card-v02{"aria-expanede" => "false", :role => "treeitem"}
        .by-card-content-v02{:style => "padding-top: 12px;"}
          .cwrapper{ id: "cwrapper_#{collection.id}", 'data-nonce' => nonce, 'data-collection-id' => collection.id, class: uncollected ? 'uncollected' : '' }
            %div{style:'font-size:120%;'}
              - if uncollected
                %p{style: 'font-size: 0.8rem; color: #222222;'}= t(:uncollected_works_collection_explanation)
              - else
                %span.ctitle_only{ style: 'display:none;' }= collection.title
                %span.ctitle
                  - extra_data = collection.created_at > 2.minutes.ago ? { 'data-focus-on-me': 'true' } : {}
                  - ctitle = "#{collection.title}#{collection.subtitle.present? ? ': '+collection.subtitle : '' }"
                  - manifestation_count = toc_node.count_manifestations(role, authority_id, involved_on_collection_level)
                  - if children.present?
                    - if !involved_on_collection_level
                      = t(:out_of)
                    = link_to ctitle, collection_path(collection), extra_data
                  - else
                    = ctitle
                  - if manifestation_count > 0
                    %span.count-badge= " (#{manifestation_count})"
                - if current_user && current_user.editor?
                  - if type_prefix.present?
                    = " (#{type_prefix})"
                  != '&nbsp;&nbsp;&nbsp;'
                  = link_to t(:edit), collection_manage_path(collection.id), style: 'font-size: 70%;'
              - ias = collection.involved_authorities
              - authorities = {}
              - ias.each do |ia|
                - if authorities[ia.role].present?
                  - authorities[ia.role] << ia.authority
                - else
                  - authorities[ia.role] = [ia.authority]
              - InvolvedAuthority::ROLES_PRESENTATION_ORDER.each do |r|
                - next unless authorities[r].present?
                - if authorities[r].size > 1
                  - authorities[r].each do |authority|
                    %p= "#{authority.name} (#{textify_role(r, authority.gender)})"
                - else
                  - authority = authorities[r].first
                  - if authority.id == authority_id # if the single authority is the same as the one whose page we are on
                    - next if r.to_sym == role # this is implicit
                  %p= "#{authority.name} (#{textify_role(r, authority.gender)})" # author X may have a work in which they are both an author and an illustrator, for example.
              - if collection.publisher_line.present?
                %p
                  - pyear = collection.pub_year.present? ? ", #{collection.pub_year}" : ''
                  - unless pyear.strip == ', 0' # special case to suppress year of a collection we want to place at the head of the page
                    = "#{collection.publisher_line}#{pyear}"
            - if editable && (collection.uncollected? || involved_on_collection_level)
              -# only show editable collections for collections where this particular author is a principal contributor
              = render partial: 'shared/manage_collection', locals: { collection: collection, title: collection.title, nonce: nonce }
            - else
              - unless children.empty?
                %ul.toclist
                  = render partial: 'authors/toc_node', collection: children,
                          locals: { role: role, authority_id: authority_id, editable: editable, nonce: nonce,
                                    uncollected: uncollected, involved_on_collection_level: involved_on_collection_level }
      %br
  - elsif toc_node.is_a?(TocTree::PlaceholderNode)
    -# Placeholder, toc_node should be a String with HTML layout
    - ci = toc_node.collection_item
    - if toc_node.markdown.present?
      %br
      - if ci.alt_title.present?
        %h4= ci.alt_title
      != MultiMarkdown.new(ci.markdown).to_html
    - elsif ci.alt_title.present?
      = ci.alt_title
-# rubocop:enable Style/CaseLikeIf
