- if @ingestible.errors.any?
  #error_explanation
    %h2= t('ingestible.invalid')
    %ul
      - @ingestible.errors.full_messages.each do |message|
        %li= message
#need_to_save{style: 'display:none; background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 10px;'}
  %h2= t('ingestible.need_to_save')
  %p= t('ingestible.need_to_save_explanation')
%ul.nav.nav-tabs{ style: 'width: 100%;' }
  %li.nav-item
    %a.nav-link.active{ href: '#general', 'data-toggle': 'tab', style: 'width: unset;' }= t('.general')
  - unless @ingestible.new_record?
    %li.nav-item
      %a.nav-link#full_markdown_header{href: '#full_markdown', 'data-toggle': 'tab', style: 'width: unset;'}= t('.full_markdown')
    %li.nav-item
      %a.nav-link#toc_header{href: '#toc', 'data-toggle': 'tab', style: 'width: unset;'}= t('.toc')
    %li.nav-item
      %a.nav-link#texts_header{ href: '#texts', 'data-toggle': 'tab', style: 'width: unset;' }= t('.texts')
.tab-content
  .tab-pane.active#general
    = form_for @ingestible do |f|
      .ingestible_edit
        .field
          = f.label t('ingestible.title')
          %b= f.text_field :title, style: 'width:80%'
        .field
          - if @ingestible.originating_task.present?
            %b= link_to t('ingestible.originating_task'), @ingestible.originating_task, style: 'width:80%'
          
        .field{style: 'border: 1px solid #ccc; padding: 10px;'}
          %h3= t('ingestible.volume')
          - vid = @ingestible.volume_id.present? ? @ingestible.volume_id : @ingestible.prospective_volume_id
          - if vid.present? || @ingestible.prospective_volume_title.present?
            %b#volume_title= title_from_prospective_volume_id(vid, @ingestible.prospective_volume_title)
            %button.btn-small-outline-v02#change_volume{style: 'display: unset;'}
              %b.btn-text-v02= t(:edit)
          .volume-details{style: vid.present? ? 'display:none;' : ''}
            = f.label t('ingestible.volume_by_author')
            = autocomplete_field_tag :author,
                                     '',
                                     autocomplete_authority_full_ingestibles_path,
                                     id: 'aterm',
                                     style: 'width:400px;',
                                     id_element: '#authority_id',
                                     class: 'ingestible-autocomplete-author',
                                     data: { loading_text: t(:loading) }
            = hidden_field_tag :authority_id, value: '', id: 'authority_id'
            = f.check_box :no_volume
            = f.label t('ingestible.no_volume')
            &nbsp;
            %span{id: 'explain_no_volume'}= '[?]'
            %br
            = select_tag :authority_volumes, [], {id: 'authority_volumes', style: 'display:none;'}
            %br

            = f.label t('ingestible.any_volume')
            = autocomplete_field_tag :volume, '', autocomplete_collection_full_ingestibles_path,
                                     id: 'cterm', style: 'width:400px;', id_element: '#prospective_volume_id',
                                     class: 'ingestible-autocomplete-volume',
                                     data: { loading_text: t(:loading) }
            %button.btn-small-outline-v02#toggle_advanced_search{ type: 'button', style: 'display: unset;' }
              %b.btn-text-v02= t('ingestible.advanced_collection_search')
            #advanced_collection_search{ style: 'display: none; border: 1px solid #ccc; padding: 10px;' }
              %h4= t('ingestible.advanced_search_title')
              #advanced_search_form{ data: { search_url: advanced_collection_search_ingestibles_path } }
                .row
                  .col-md-6
                    %h5= t('ingestible.search_filters')
                    .field
                      = label_tag :advanced_search_title, t('ingestible.search_by_title')
                      = text_field_tag :advanced_search_title, '', style: 'width: 100%;'
                    .field{ style: 'margin-top: 10px;' }
                      = label_tag :advanced_search_authority, t('ingestible.search_by_authority')
                      = text_field_tag :advanced_search_authority,
                                       '',
                                       style: 'width: 100%;',
                                       data: { autocomplete_url: autocomplete_authority_full_ingestibles_path }
                      = hidden_field_tag :advanced_search_authority_id, ''
                    .field{ style: 'margin-top: 10px;' }
                      = label_tag :collection_types, t('ingestible.collection_type_filter')
                      %br
                      - Collection.collection_types.keys.reject { |t| t == 'uncollected' }.each do |type|
                        = check_box_tag "collection_type_#{type}", type, false, class: 'collection-type-checkbox'
                        = label_tag "collection_type_#{type}",
                                    t("activerecord.attributes.collection.collection_types.#{type}"),
                                    style: 'font-weight: normal; margin-left: 5px; margin-left: 15px;'
                        %br
                    .field{ style: 'margin-top: 15px;' }
                      %button.btn.btn-primary#advanced_search_button{ type: 'button' }= t('ingestible.search_button')
                  .col-md-6
                    %h5= t('ingestible.matching_collections')
                    - no_results_data = { no_results_text: t('ingestible.no_results') }
                    .search-results-column#advanced_search_results{ data: no_results_data }
            %br
            #sub_collection_selector{ style: 'display:none; margin-top: 10px; margin-bottom: 10px;' }
              = label_tag :sub_collection_id, t('ingestible.sub_collection_within')
              = select_tag :sub_collection_id,
                           options_for_select([]),
                           include_blank: t('ingestible.select_sub_collection'),
                           style: 'width:400px;',
                           data: { blank_text: t('ingestible.select_sub_collection') }
            = t(:or)
            %br
            = f.label t('ingestible.create_new_volume')
            = f.text_field :prospective_volume_title, style: 'width:400px;'
            = f.hidden_field :prospective_volume_id, id: 'prospective_volume_id'
            %br
            = t(:or)
            %br
            = f.label t('ingestible.pick_periodical')
            = f.select :periodical_id, options_for_select(Collection.by_type(:periodical).map{|j| [j.title, j.id]}, @ingestible.periodical_id), {include_blank: true, style: 'width:400px;'}
            %br
            %div#periodical_issues_div{style: 'display:none;'}
              = t('ingestible.pick_issue')
              = select_tag :periodical_issues, [], {id: 'periodical_issues'}
            %br
            = t(:or)
            %br
            %button.btn-small-outline-v02#create_new_periodical{ type: 'button', style: 'display: unset;' }
              %b.btn-text-v02= t('ingestible.create_new_periodical_button')

        .field{ style: 'border: 1px solid #ccc; padding: 10px; margin-top: 10px;' }
          %h3= t('ingestible.project')
          = f.label t('ingestible.select_project')
          = f.select :project_id,
            options_for_select(Project.active.order(:name).map { |p| [p.name, p.id] },
                               @ingestible.project_id),
            { include_blank: t('ingestible.no_project') },
            { class: 'form-control' }
          %p.text-muted= t('ingestible.project_help')

        .field
          -#= f.label :scenario
          -#= f.select :scenario, options_for_select(Ingestible.scenarios.map{|k,v| [t("ingestible.scenario.#{k}"), k]}, @ingestible.scenario)
          = f.label :status
          %b= t("ingestible.status.#{@ingestible.status}")
          = f.hidden_field :status, value: @ingestible.status
        = render partial: 'collection_authorities', locals: {authorities: @ingestible.collection_authorities}
        %hr
        %h3= t('ingestible.default_authorities_for_texts')
        %p.text-muted= t('ingestible.default_authorities_help')
        = render partial: 'authorities', locals: {authorities: @ingestible.default_authorities}
        %hr
        %h2= t('ingestible.defaults')
        = f.label t(:genre)
        - genres = (['mixed'] + Work::GENRES).map { |genre| [textify_genre(genre), genre] }
        = f.select :genre, options_for_select(genres, @ingestible.genre), {include_blank: true}
        = f.label t(:publisher)
        = f.text_field :publisher, style: 'width:400px;'
        = f.label t(:year_published)
        = f.text_field :year_published, style: 'width:100px;'
        %br
        = f.label t(:orig_lang)
        = f.select :orig_lang, options_for_select(get_langs.map {|lang| [textify_lang(lang), lang]}, @ingestible.orig_lang)
        = f.label t(:default_copyright_for_protected_texts)
        - default_ip = @ingestible.intellectual_property || 'by_permission'
        = f.select :intellectual_property, options_for_select(copyrighted_ip_options, default_ip)
        %br
        = f.label t(:publisher_link)
        = f.text_field :pub_link, style: 'width:400px;'
        %br
        = f.label t(:publisher_link_text)
        = f.text_field :pub_link_text, style: 'width:400px;'
        %hr
        .field
          = f.label t('ingestible.credits')
          = f.text_area :credits
        .field
          = f.label :comments
          = f.text_area :comments
        .field
          = f.check_box :attach_photos
          = f.label t('ingestible.attach_photos')
          &nbsp;
          %span{id: 'explain_attach_photos'}= '[?]'

        - if @ingestible.persisted? && @ingestible.docx.present?
          %p
            = t('ingestible.current_file')
            = link_to @ingestible.docx.filename.to_s, url_for(@ingestible.docx)
            = t('ingestible.or_replace_file')
        - else
          %b= t(:upload_file)
          = t(:file_can_be_skipped)
        = f.file_field :docx
        = f.label t('.problem')
        = f.text_area :problem
      .actions
        = f.submit t(:save), class: 'btn btn-primary'
  - unless @ingestible.new_record?
    .tab-pane#full_markdown
      %h2= t('.full_markdown')
      .container-fluid
        .row
          .col-md-12
            = form_for @ingestible, url: update_markdown_ingestible_path(@ingestible) do |f|
              .markdown_container.row
                .col-sm-3
                  #legacy_markdown_link
                  %h2= t(:markdown)
                  %button.btn-small-outline-v02#add_stanza_break{ style: 'display:unset' }
                    %b.btn-text-v02= t(:add_stanza_break)
                  %button.btn-small-outline-v02#add_angled_brackets{ style: 'display:unset' }
                    %b.btn-text-v02= t(:add_angled_brackets)
                  %button.btn-small-outline-v02#remove_angled_brackets{ style: 'display:unset' }
                    %b.btn-text-v02= t(:remove_angled_brackets)
                  %button.btn-small-outline-v02#minuses_to_makafim{ style: 'display:unset' }
                    %b.btn-text-v02= t(:minuses_to_makafim)
                  = f.text_area :markdown, class: 'textarea100 markdown'
                .col-sm-9
                  %h2= t(:display_text)
                  #preview{ style: 'padding-left:10px;padding-right:15px;background:#d2cfcf; overflow-y:auto' }
                    != raw(@html)
                    %br
                .actions{style: 'width: 100%;'}
                  = f.submit t(:save), class: 'btn btn-primary'
      = render partial: 'shared/markdown_utils', locals: { container_id: 'full_markdown', element_id: 'ingestible_markdown' }
    .tab-pane#toc
      %h2= t('.toc')
      .field.ingestible_edit
        = button_tag t('ingestible.included_works'), id: 'edit_toc'
        %br
        #toc_div= render partial: 'toc'
      -#= form_for @ingestible do |f|
        -#= f.text_area :toc_buffer, class: 'textarea100'
      -#  .actions
      -#    = f.submit t(:save), class: 'btn btn-primary'
    .tab-pane#texts
      - unless @ingestible.texts.empty?
        = render partial: 'ingestible_texts/edit',
                 locals: { ingestible: @ingestible, index: (params[:text_index] || 0).to_i }
  - if @ingestible.persisted?
    .review
      = link_to t('.review'), review_ingestible_path(@ingestible), class: 'btn btn-primary', style: 'width:100%;'
:javascript
  $(function() {
    if (#{params[:text_index].present?}) {
      $('#texts_header').click();
    } else if (#{@tab.present?}) {
      $("##{@tab}_header").click();
    }

    $('#explain_no_volume').popover({content:
    "#{t('ingestible.no_volume_explanation')}", 
    trigger: 'hover', placement: 'right'});
    $('#explain_attach_photos').popover({content: 
    "#{t('ingestible.attach_photos_explanation')}", 
    trigger: 'hover', placement: 'right'});
    $('#aterm').on('railsAutocomplete.select', function(event, data){
      $('#authority_id').val(data.item.id);
      // look up volumes by authority
      url = "#{authority_volumes_path}?id=" + data.item.id;
      $.ajax({
        url: url,
        success: function(data) {
          $('#authority_volumes').show();
          if (data['volumes'].length == 0 && data['publications'].length == 0) {
            $('#authority_volumes').hide();
          } else {
            $('#authority_volumes').empty();
            $('#authority_volumes').append($('<option>', {
              value: '',
              text: ''
            }));
            data['volumes'].forEach(function(volume) {
              $('#authority_volumes').append($('<option>', {
                value: volume.id,
                text: volume.title
              }));
            });
            data['publications'].forEach(function(publication) {
              $('#authority_volumes').append($('<option>', {
                value: 'P'+publication.id.toString(),
                text: "#{t('ingestible.new_volume')} " + publication.title,
                'data-actual-title': publication.title
              }));
            });
          }
        }
      });
    });
    $('#authority_volumes').on('change', function() {
      var volumeId = $('#authority_volumes').val();
      $('#prospective_volume_id').val(volumeId);
      new_title = $('#authority_volumes option:selected').text();
      // For publications, use the actual title without the prefix
      actual_title = $('#authority_volumes option:selected').data('actual-title');
      var display_title = actual_title || new_title;

      // Set the autocomplete field (for existing collections)
      $('#cterm').val(display_title);

      // Clear the "create new volume" field (we're selecting existing, not creating new)
      $('#ingestible_prospective_volume_title').val('');

      $('#volume_title').text(new_title);
      $('#ingestible_no_volume').prop('checked', false);
      $('#need_to_save').show();
      // Trigger sub-collections loading
      $(document).trigger('collection:selected', [volumeId]);
    });
    $('#periodical_issues').on('change', function() {
      if($('#periodical_issues').val() == '!new') {
        // show pop-up asking for new periodical issue title
        $('<form>#{t("ingestible.new_issue_title")}<input type="text" style="z-index:10000" name="issue_title"><br></form>').dialog({
          modal: true,
          buttons: {
            'OK': function () {
              var name = $('input[name="issue_title"]').val();
              $.post("#{collection_add_periodical_issue_path(999)}".replace('999', $('#ingestible_periodical_id').val()), {title: name});
              $(this).dialog('close');
            },
            'Cancel': function () {
              $(this).dialog('close');
            }
          }
        });
      } else {
        var issueId = $('#periodical_issues').val();
        $('#prospective_volume_id').val(issueId);
        new_title = $('#periodical_issues option:selected').text();

        // Set the autocomplete field (for existing collections)
        $('#cterm').val(new_title);

        // Clear the "create new volume" field (we're selecting existing, not creating new)
        $('#ingestible_prospective_volume_title').val('');

        $('#volume_title').text(new_title);
        // Trigger sub-collections loading
        $(document).trigger('collection:selected', [issueId]);
    }
      $('#need_to_save').show();
      $('#ingestible_no_volume').prop('checked', false);
    });

    $('#ingestible_periodical_id').on('change', function() {
      $('#ingestible_no_volume').prop('checked', false);
      url = "#{collection_periodical_issues_path(999)}".replace('999', $(this).val());
      $.ajax({
        url: url,
        success: function(data) {
          if (data['issues'].length > 0) {
            $('#periodical_issues').empty();
            $('#periodical_issues_div').show();
            $('#periodical_issues').append($('<option>', {
              value: '',
              text: ''
            }));
            data['issues'].forEach(function(issue) {
              $('#periodical_issues').append($('<option>', {
                value: issue.id,
                text: issue.title
              }));
            });
            $('#periodical_issues').append($('<option>', {
              value: '!new',
              text: "#{t('ingestible.add_new_issue')}"
            }));

            // Check if there's a pending issue to select (from create_new_periodical)
            if (window.pendingIssueId) {
              $('#periodical_issues').val(window.pendingIssueId);
              $('#periodical_issues').trigger('change');
              window.pendingIssueId = null;
            }
          }
        }
      });

    });
    $('#cterm').on('railsAutocomplete.select', function(event, data){
      $('#prospective_volume_id').val(data.item.id);
      $('#ingestible_prospective_volume_title').val(data.item.value);
      $('#volume_title').text(data.item.value);
      $('#ingestible_no_volume').prop('checked', false);
      $('#need_to_save').show();
      // Trigger sub-collections loading
      $(document).trigger('collection:selected', [data.item.id]);
    });
    $('#change_volume').on('click', function(e) {
      e.preventDefault();
      $('.volume-details').toggle();
    });
    $('#ingestible_no_volume').on('change', function() {
      if ($('#ingestible_no_volume').is(':checked')) {
        $('#authority_volumes').hide();
        $('#periodical_issues_div').hide();
        $('#prospective_volume_id').val('');
        $('#prospective_volume_title').val('');
        $('#volume_title').text('');
        $('#ingestible_periodical_id').val('');
        $('#ingestible_prospective_volume_title').val('');
        $('#need_to_save').show();
        // Hide sub-collections dropdown
        $('#sub_collection_selector').hide();
        $('#sub_collection_id').empty();
      } else {
        $('#authority_volumes').show();
      }
    });
    $('#ingestible_prospective_volume_title').on('change', function() {
      $('#ingestible_no_volume').prop('checked', false);
    });
    $('#create_new_periodical').on('click', function(e) {
      e.preventDefault();
      // Create a dialog for entering periodical and first issue titles
      var dialogHtml = '<form>' +
        '<label>#{t('ingestible.periodical_title')}:</label><br>' +
        '<input type="text" name="periodical_title" id="new_periodical_title" ' +
        'style="width:100%; margin-bottom:10px;"><br>' +
        '<label>#{t('ingestible.first_issue_title')}:</label><br>' +
        '<input type="text" name="issue_title" id="new_issue_title" style="width:100%;">' +
        '</form>';

      $(dialogHtml).dialog({
        modal: true,
        title: '#{t('ingestible.create_new_periodical')}',
        width: 500,
        buttons: {
          '#{t(:ok)}': function () {
            var periodicalTitle = $('#new_periodical_title').val().trim();
            var issueTitle = $('#new_issue_title').val().trim();

            if (!periodicalTitle || !issueTitle) {
              alert('#{t('ingestible.both_titles_required')}');
              return;
            }

            var dialog = $(this);

            $.post("#{create_periodical_with_issue_path}", {
              periodical_title: periodicalTitle,
              issue_title: issueTitle
            })
            .done(function(data) {
              if (data.success) {
                // Populate the periodical dropdown with the new periodical
                $('#ingestible_periodical_id').append($('<option>', {
                  value: data.periodical_id,
                  text: data.periodical_title,
                  selected: true
                }));

                // Trigger the periodical selection to load issues
                $('#ingestible_periodical_id').trigger('change');

                // Store the newly created issue ID to select after issues are loaded
                window.pendingIssueId = data.issue_id;
                // The AJAX handler that populates #periodical_issues should check window.pendingIssueId
                // and select the issue if present, then clear window.pendingIssueId.

                dialog.dialog('close');
              } else {
                alert('#{t('ingestible.creation_failed')}: ' + data.error);
              }
            })
            .fail(function() {
              alert('#{t('ingestible.creation_failed')}');
            });
          },
          '#{t(:cancel)}': function () {
            $(this).dialog('close');
          }
        }
      });
    });
    $('#edit_toc').on('click', function(e) {
      e.preventDefault();
      $('#generalDlg').load("#{ @ingestible.id.present? ? edit_toc_ingestible_path(@ingestible) : ''}");
      $('#generalDlg').modal('show');
    });
  });
