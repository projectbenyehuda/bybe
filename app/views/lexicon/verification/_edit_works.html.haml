-# Works editing section for verification workbench - Reuses the works management interface from person_works/index
- checklist = @entry.verification_progress&.dig('checklist', 'works') || {}
- work_items = checklist['items'] || {}

-# Get proposed matches (NOT persisted to database yet)
- proposed_matches = defined?(@work_matches) ? @work_matches : {}
- auto_match_count = proposed_matches.size

:css
  /* Make modal wider when displaying works section */
  #generalDlg:has(#works-section) .modal-dialog {
    max-width: 90vw;
    width: 90vw;
    margin: 1.75rem auto;
  }

  #generalDlg:has(#works-section) .modal-body {
    max-height: 80vh;
    overflow-y: auto;
    overflow-x: hidden;
  }

  #works-section .table-responsive {
    overflow-x: auto;
    overflow-y: visible;
  }
  #works-section table {
    min-width: 100%;
  }
  /* Fix checkbox vertical alignment in table rows */
  #works-section table tbody td {
    vertical-align: middle;
  }
  #works-section .form-check {
    margin-bottom: 0;
    min-height: auto;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #works-section .form-check-input {
    margin-top: 0;
    position: static;
    float: none;
  }
  /* Proposed match styling */
  .proposed-match {
    background: #e7f5e7;
    border: 1px solid #a8d5a8;
    border-radius: 4px;
    padding: 8px 12px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .proposed-match-info {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .proposed-match-actions {
    display: flex;
    gap: 4px;
  }
  .btn-confirm-match {
    background: #28a745;
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }
  .btn-confirm-match:hover {
    background: #218838;
  }
  .btn-reject-match {
    background: #dc3545;
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }
  .btn-reject-match:hover {
    background: #c82333;
  }
  .similarity-badge {
    background-color: yellow;
    color: black;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 12px;
    font-weight: bold;
  }

#works-section
  - unless @item.authority
    .alert.alert-warning.mb-3
      = t('lexicon.person_works.form.no_authority_warning')

  - if auto_match_count > 0
    .alert.alert-success.mb-3
      = t('lexicon.verification.edit.auto_matched_works', count: auto_match_count)

  %a.btn.btn-primary.add-person-work.mb-3= t('lexicon.person_works.index.add_work')

  - if @item.works.any?
    - @item.works.includes(:publication, :collection).group_by(&:work_type).each do |work_type, works|
      %h4= LexPersonWork.human_enum_name(:work_type, work_type)
      .table-responsive
        %table.table.table-sm
          %thead
            %tr
              %th.text-center{ style: 'min-width: 80px;' }
                = t('lexicon.verification.edit.verified')
              %th{ style: 'min-width: 150px;' }= LexPersonWork.human_attribute_name(:title)
              %th{ style: 'min-width: 120px;' }= LexPersonWork.human_attribute_name(:publisher)
              %th{ style: 'min-width: 120px;' }= LexPersonWork.human_attribute_name(:publication_place)
              %th{ style: 'min-width: 100px;' }= LexPersonWork.human_attribute_name(:publication_date)
              %th{ style: 'min-width: 150px;' }= LexPersonWork.human_attribute_name(:publication)
              %th{ style: 'min-width: 150px;' }= LexPersonWork.human_attribute_name(:collection)
              %th{ style: 'min-width: 150px;' }= LexPersonWork.human_attribute_name(:comment)
              %th.text-center{ style: 'min-width: 120px;' }= t(:actions)
          %tbody
            - works.each do |w|
              - work_verified = work_items.dig(w.id.to_s, 'verified') || false
              %tr{ data: { work_id: w.id } }
                %td.text-center
                  .form-check.d-inline-block
                    = check_box_tag "work_verified_#{w.id}", '1', work_verified,
                                    class: 'form-check-input verify-work-checkbox',
                                    data: { work_id: w.id }
                %td= w.title
                %td= w.publisher
                %td= w.publication_place
                %td= w.publication_date
                %td{ id: "publication-cell-#{w.id}" }
                  - proposed_match = proposed_matches[w.id]
                  - if proposed_match
                    .proposed-match{ data: { work_id: w.id,
                                             publication_id: proposed_match[:publication_id],
                                             collection_id: proposed_match[:collection_id] } }
                      .proposed-match-info
                        %span.fw-bold= proposed_match[:publication_title]
                        %span.similarity-badge #{proposed_match[:similarity]}%
                      .proposed-match-actions
                        %button.btn-confirm-match{ title: 'Confirm match', data: { action: 'confirm' } } ✓
                        %button.btn-reject-match{ title: 'Reject match', data: { action: 'reject' } } ✕
                  - elsif w.publication
                    = link_to w.publication.title, publication_path(w.publication),
                              title: w.publication.title,
                              target: '_blank',
                              rel: 'noopener'
                %td{ id: "collection-cell-#{w.id}" }
                  - proposed_match = proposed_matches[w.id]
                  - if proposed_match && proposed_match[:collection_title]
                    .text-muted.small (proposed: #{proposed_match[:collection_title]})
                  - elsif w.collection
                    = link_to w.collection.title, collection_path(w.collection),
                              title: w.collection.title,
                              target: '_blank',
                              rel: 'noopener'
                %td= w.comment
                %td.text-center
                  = link_to t(:edit), '#',
                            class: 'edit-person-work btn btn-sm btn-outline-primary me-1',
                            data: { id: w.id }
                  = link_to t(:delete),
                            lexicon_work_path(w),
                            remote: true, data: { confirm: t(:are_you_sure) }, method: :delete,
                            class: 'btn btn-sm btn-outline-danger'
  - else
    .alert.alert-info
      = t('lexicon.verification.edit.no_works')

  %hr.my-4

  .form-check.mt-3
    = check_box_tag :mark_verified, '1', checklist['verified'] || false,
                    class: 'form-check-input',
                    id: 'mark_all_works_verified'
    = label_tag :mark_all_works_verified,
                t('lexicon.verification.edit.mark_all_works_verified'),
                class: 'form-check-label'

  .modal-footer
    %button.btn.btn-secondary{ type: 'button', data: { dismiss: 'modal' } }
      = t('close')

:javascript
  // Initialize works verification interface
  (function() {
    const entryId = #{@entry.id};
    const personId = #{@item.id};

    // Handle individual work verification checkbox changes
    $('.verify-work-checkbox').on('change', function() {
      const checkbox = $(this);
      const workId = checkbox.data('work-id');
      const verified = checkbox.prop('checked');

      $.ajax({
        url: `/lex/verification/${entryId}/update_checklist`,
        type: 'PATCH',
        headers: {
          'X-CSRF-Token': $('meta[name="csrf-token"]').attr('content')
        },
        data: {
          path: `works.items.${workId}`,
          verified: verified,
          notes: ''
        },
        success: function(data) {
          // Update progress bar
          if (typeof updateProgressBar === 'function') {
            updateProgressBar(data.percentage);
          }

          // Check if all individual works are verified
          updateMarkAllCheckbox();
        },
        error: function(xhr) {
          alert('Error updating work verification: ' + (xhr.responseJSON?.error || 'Unknown error'));
          // Revert checkbox
          checkbox.prop('checked', !verified);
        }
      });
    });

    // Handle "Mark all as verified" checkbox
    $('#mark_all_works_verified').on('change', function() {
      const checkbox = $(this);
      const verified = checkbox.prop('checked');

      $.ajax({
        url: `/lex/verification/${entryId}/update_checklist`,
        type: 'PATCH',
        headers: {
          'X-CSRF-Token': $('meta[name="csrf-token"]').attr('content')
        },
        data: {
          path: 'works',
          verified: verified,
          notes: ''
        },
        success: function(data) {
          // Update progress bar and overall checklist
          if (typeof onSectionEditSuccess === 'function') {
            onSectionEditSuccess('section-works')(data);
          }

          // Close modal
          closeModal();

          // Reload page to reflect changes
          setTimeout(() => location.reload(), 500);
        },
        error: function(xhr) {
          alert('Error updating works section: ' + (xhr.responseJSON?.error || 'Unknown error'));
          // Revert checkbox
          checkbox.prop('checked', !verified);
        }
      });
    });

    // Update "Mark all as verified" checkbox based on individual checkboxes
    function updateMarkAllCheckbox() {
      const totalCheckboxes = $('.verify-work-checkbox').length;
      const checkedCheckboxes = $('.verify-work-checkbox:checked').length;

      if (totalCheckboxes > 0 && checkedCheckboxes === totalCheckboxes) {
        $('#mark_all_works_verified').prop('checked', true);
      } else {
        $('#mark_all_works_verified').prop('checked', false);
      }
    }

    // Handle proposed match confirmation
    $('.btn-confirm-match').on('click', function(e) {
      e.preventDefault();
      const btn = $(this);
      const matchBox = btn.closest('.proposed-match');
      const workId = matchBox.data('work-id');
      const publicationId = matchBox.data('publication-id');
      const collectionId = matchBox.data('collection-id');

      // Disable button during request
      btn.prop('disabled', true);

      $.ajax({
        url: `/lex/verification/${entryId}/confirm_work_match`,
        type: 'PATCH',
        headers: {
          'X-CSRF-Token': $('meta[name="csrf-token"]').attr('content')
        },
        data: {
          work_id: workId,
          publication_id: publicationId,
          collection_id: collectionId
        },
        success: function(data) {
          // Remove all other proposed matches for the same publication
          $(`.proposed-match[data-publication-id="${publicationId}"]`).each(function() {
            if ($(this).data('work-id') !== workId) {
              $(this).fadeOut(300, function() { $(this).remove(); });
            }
          });

          // Reload the works section to show the confirmed match
          reloadWorksSection();
        },
        error: function(xhr) {
          alert('Error confirming match: ' + (xhr.responseJSON?.error || 'Unknown error'));
          btn.prop('disabled', false);
        }
      });
    });

    // Handle proposed match rejection
    $('.btn-reject-match').on('click', function(e) {
      e.preventDefault();
      const btn = $(this);
      const matchBox = btn.closest('.proposed-match');

      // Simply hide the proposed match (don't persist rejection)
      matchBox.fadeOut(300, function() {
        matchBox.remove();
      });
    });

    // Handle add work button
    $('a.add-person-work').click(function(e) {
      e.preventDefault();
      openModal(`/lex/people/${personId}/works/new`, function() {
        // Reload works section after adding
        reloadWorksSection();
      });
    });

    // Handle edit work buttons
    $('.edit-person-work').click(function(e) {
      e.preventDefault();
      const workId = $(this).data('id');
      openModal(`/lex/works/${workId}/edit`, function() {
        // Reload works section after editing
        reloadWorksSection();
      });
    });

    // Reload works section after CRUD operations
    function reloadWorksSection() {
      $.ajax({
        url: `/lex/verification/${entryId}/edit_section`,
        type: 'GET',
        data: { section: 'works' },
        success: function(html) {
          // Replace the modal content with updated works list
          $('#generalDlgBody').html(html);
        },
        error: function(xhr) {
          alert('Error reloading works: ' + (xhr.responseJSON?.error || 'Unknown error'));
        }
      });
    }

    // Initial check of "Mark all" checkbox
    updateMarkAllCheckbox();

    // Reload page when modal closes to update the works section
    $('#generalDlg').one('hidden.bs.modal', function() {
      location.reload();
    });
  })();
